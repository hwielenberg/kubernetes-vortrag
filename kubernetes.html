<!DOCTYPE html>
<html>
  <head>
    <title>Kubernetes</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: left, middle

# Agenda

1. Vortrag: Einführung in k8s
2. Fragerunde
3. Hands-On
4. Mehr Fragen

---
# Was kann kubernetes?

Kubernetes ist ein Container Orchestrierer, und übernimmt dabei funktionen wie:

 - Deployment, Verfügbarkeit, Resourcen Verwaltung, Kommunikation, Service Discovery

# Was kann es nicht?

- Kubernets baut keine Container. Es kann aber mit einer Vielzahl von Containern Umgehen. -> Docker, rkt, ...
- Keine Pipeline für Continous Delivery. -> Gitlab, Jenkins, ...
- Logging, Monitoring. -> ELK-Stack, Grafana, ...


---
#### Pod

Ein Pod ist die kleinste interagierbare Komponente in kubernetes.

Auf Ebene der Pods wird in kubernetes redundante Applikationen abgebildet. Sowohl für Lastverteilung, als auch für Ausfallsicherheit.

Ein Pod führt ein (oder mehrere) docker images aus.

---

#### Deployment

Über Deployments steuert man die Menge der zur verfügung gestellten Pods, sowie das automatische Update von Container Versionen, und sind normalerweise die primäre Interaktion die man mit Kubernetes hat.

Deployments unterstützen zusätzlich ein Rollback auf vorige versionen.

#### Replica Set

Zwischen Deployment und Pod gibt es die zusätzliche Ebene der Replica Set.

Jedes Mal wenn es an der k8s config eine Änderung gibt (z.B. neue image Version) wird ein neues Replica Set erzeugt.
Für die Dauer der Migrationen der Pods auf den neusten Stand hat ein Deployment zwei Replica Sets.

```
localhost:~ henning$ kubectl get pods | grep ase-frontend

test-ase-frontend-1058840217-u23m7       1/1       Running             0          44m
test-ase-frontend-1058840217-xowiu       1/1       Running             0          44m
...
test-ase-frontend-1058840217-u23m7       1/1       Running             0          45m
test-ase-frontend-1058840217-xowiu       1/1       Running             0          44m
test-ase-frontend-1091542682-xd593       0/1       Running             0          11s
...
test-ase-frontend-1058840217-u23m7       1/1       Running             0          45m
test-ase-frontend-1058840217-xowiu       0/1       Terminating         0          44m
test-ase-frontend-1091542682-e9dqu       0/1       ContainerCreating   0          2s
test-ase-frontend-1091542682-xd593       1/1       Running             0          22s
...
test-ase-frontend-1091542682-e9dqu       1/1       Running             0          24s
test-ase-frontend-1091542682-xd593       1/1       Running             0          44s
```

---
# Kubernetes Komponenten
![:scale 80%](img/k8s2.png "Logo Title Text 1")

---
#### Container

Ein `Pod` ist eine Zusammenführung mehrerer Container zu einer gemeinsamen Einheit.

Im Normalfall hat ein Pod ein Container.

Ein (docker) Container sollte immer nur ein Prozess ausführen.
Falls zwei Prozesse sehr dicht beieinander laufen müssen kann man diese in einem Pod laufen lassen.

Innerhalb eines Pod können Container über `localhost` miteinander Kommunizieren und sich Dateisysteme teilen.

---
#### Cluster

Eine Gruppe von VM (nodes) auf denen kubernetes installiert ist bilden zusamen ein Cluster.

#### Node

Eine VM die u.a. docker images ausführt.

#### Namespace

Zur Strukturierung eines Clusters in mehrere Bereiche. Ein Cluster kann z.B. mehrere Umgebungen ausliefern.

Namespaces sollten idealerweise nicht genutzt werden um `dev` und `prod` Umgebungen zu trennen.

---
#### Service

Servives Gruppieren Pods und machen sie unter einer gemeinsamen IP:PORT verfügbar. Kubernetes verteilt den Traffic auf die Pods nach Verfügbarkeit über ein RoundRobin Prinzip.

Im Normalfall gibt es eine 1-zu-1 Beziehung zwischen Service und Pod.

---
### Wie Konfiguriert man k8s eigentlich?

YAML
```yaml
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: raumschilder
  name: raumschilder
spec:
  replicas: 1
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: raumschilder
    spec:
      imagePullSecrets:
        - name: gitlab.neuland-bfi.de
      containers:
      - image: gitlab.neuland-bfi.de:5043/stefan.kuper/raumschilder:latest
        name: nodejs
        resources: {}
      restartPolicy: Always
status: {}
---
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: null
  labels:
    app: raumschilder
  name: raumschilder
spec:
  ports:
  - name: nodejs
    port: 3000
  selector:
    app: raumschilder
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  labels:
    app: raumschilder
  name: raumschilder
  annotations:
    ingress.kubernetes.io/whitelist-source-range: "10.66.0.0/16,192.168.0.0/16"
spec:
  rules:
  - host: ting.neuland-bfi.de
    http:
      paths:
      - backend:
          serviceName: raumschilder
          servicePort: 3000
        path: /
```



---
#### Init Systeme in Containern

Ein Prozess pro Container, ein Init System sollte vermieden werden. _Zombie Reaper_ übernimmt Kubernetes.

Shared PID Space im Pod. Shared Ports aller Container im Pod, benachbarte Container im Pod können über `localhost` erreicht werden.

#### Memory und CPU Limits

Können auf Pod und/oder Namespace Ebene Definiert werden.

Linux `cgroups`. CPU wird _soft_ limitiert, Memory wird _hard_ per OOM-Killer limitiert.

---

#### Service Discovery

Kubernetes DNS System stellt diverse Records zum finden von Pods/Services zur verfügung: `<service>.<namespace>.svc.cluster.local`

Im Container über Umgebungsvariable.

---
#### Logging

Logfiles nicht im Container, immer nach STDOUT und STDERR. Diese können dann mit `kubectl logs` gelesen werden.

Im Cluster sollte es ein Logging System geben das diese Logfiles auf Hostebene (_Daemonset_) einsammelt, und zentral verfügbar macht (z.B: ELK)

#### Storage

Nicht im Container.

Temp Space der mit dem Pod besteht: `emptyDir`, kann von multiplen Containern im Pod genutzt werden, liegt auf dem Host:
```yaml
volumes:
  - name: scratchdir
    emptyDir: {}
```

Cloud Provider können Blocstorage in AWS/Azure/Openstack/VMWare etc, alternativ NFS/iSCSI. Blockstorage wandert mit dem Pod, und ist nur von einem Pod benutzbar.

---
# Redundante Systeme / Replicas

#### Affinity

Pods werden möglichst so verteilt, das auf einem Host nie 2 gleichzeitig laufen.

#### Readyness / Liveness Probes

An die Container eines Pod wird ein Monitoring (Liveness, Readyness) konfigiert, mit der der Zustand und die Verfügbarkeit überwacht wird.

Der _Readyness_ Probe definiert ob der Pod Traffic bekommt, _Liveness_ wird benutzt um festzustellen ob ein Service funktionert.

Können HTTP Checks, oder beliebige Scripte die im Container ausgeführt werden sein:
```yaml
readinessProbe:
  httpGet:
    port: 8080
    scheme: HTTP
    path: /ready.html
  initialDelaySeconds: 5 # Gibt der Applikation zeit zu starten
  periodSeconds: 3 # Prüf Intervall
livenessProbe:
  httpGet:
    port: 8080
    scheme: HTTP
    path: /basic_status
  initialDelaySeconds: 5
  periodSeconds: 3
```

---
# Deployment Strategien

#### Recreate
Simpel: Alle Pods Sterben, bevor neue gestartet werden.

#### Rolling-Update
"Blue/Green" deployment: neue Pods werden gestartet, warten bis _Readyness_ erfolgt ist, bevor ein alter gelöscht wird.

Über _maxUnavailable_ und _maxSurge_ wird gesteuert Wieviele Pods maximal terminiert werden dürfen, und wieviele maximal zusätzlich gestartet werden können.

Bei einem Deployment mit z.B 3 Replicas, führ ein `maxUnavailable: 0` und `maxSurge: 3` dazu, das immer erst 3 neue Pods gestartet werden, bevor die alten terminiert werden.

Pipeline:
```bash
kubectl rollout status deployment/mein-tolles-deployment -w
```
---
# Ingress, ConfigMaps, Secrets, CronJobs

#### Ingress

Ingress ist ein _Reverse Proxy_ verfügbar in diverser Variation (Nginx, Haproxy, Traefik)

`Ingress` kann, anders als ein `Service` auf HTTP *Pfad* ebene Routen:

```yaml
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: raumschilder
spec:
  rules:
  - host: ting.neuland-bfi.de
    http:
      paths:
      - backend:
          serviceName: raumschilder
          servicePort: 3000
        path: /
        - backend:
            serviceName: anderer-service
            servicePort: 3000
          path: /backend/api
```
---
#### ConfigMap

Key/Value Konfiguration die in Pods als Datei oder Umgebungsvariable verfügbar gemacht werden kann.

```yaml
apiVersion: v1
data:
  aws.region: eu-central-1
  efs-systemid.server.dns-name: fs-0801e451.efs.eu-central-1.amazonaws.com
  file.system.id: fs-0801e451
  provisioner.name: example.com/aws-efs
kind: ConfigMap
metadata: {}
```

---
#### Secret

Funktional Analog zu einer ConfigMap, wird aber vom Cluster anders behandelt. Daten sind `base64` Kodiert:

```yaml
apiVersion: v1
data:
  basic-auth-password: YmxhaGZhc2Vs
  basic-auth-user: Ymx1YmJlcg==
kind: Secret
metadata: {}
```

Inhalt wird nie auf Disk geschrieben, wird nur an Nodes geschickt die das Secret benötigen. Können im Pod auch wieder als Umgebungsvariable oder Datei verwendet werden.
---
#### CronJob

Konfiguration wie ein Deployment, Pod wird nach Unix Cron Definition gestartet.

#### Daemonset

Konfiguration ähnlich zu einem Deployment, Pods werden aber auf allen Nodes des Cluster gestartet.

---
# Fragerunde

Jetzt!

---
# `kubectl`  Installation

Installation von https://kubernetes.io/docs/tasks/tools/install-kubectl/. Mac User mit `brew install kubectl`

Bash Completion:
 ```bash
 echo "source <(kubectl completion bash)" >> ~/.bashrc
 ```
für Mac User:
```bash
brew install bash-completion
```

Kube Configs für Neuland Cluster:

https://gitlab.neuland-bfi.de/admins/ansible-neuland-infra/tree/master/roles/kubernetes/users

Datei als `~/.kube/config` ablegen.

Cheat-sheet: https://kubernetes.io/docs/reference/kubectl/cheatsheet/



    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      remark.macros.scale = function (percentage) {
        var url = this;
        return '<img src="' + url + '" style="width: ' + percentage + '" />';
      };
      var slideshow = remark.create();
    </script>
  </body>
</html>